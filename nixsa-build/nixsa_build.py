#!/usr/bin/env python

from __future__ import annotations

import os
import sys
from pathlib import Path
from shlex import quote
from subprocess import run

NIX_CONF = """\
# This is based on the nix.conf file generated by https://github.com/DeterminateSystems/nix-installer.

use-xdg-base-directories = true
experimental-features = nix-command flakes
auto-optimise-store = true
always-allow-substitutes = true
bash-prompt-prefix = (nix:$name)\\040
max-jobs = auto
extra-nix-path = nixpkgs=flake:nixpkgs
upgrade-nix-store-path-url = https://install.determinate.systems/nix-upgrade/stable/universal
"""

NIXSA_TOML = '# This file is just a marker, used by the nixsa executable to find the nixsa folder root.\n'


# pylint: disable=redefined-builtin
def sh(args: list[str | Path], input: bytes | None = None, env: dict[str, str | Path] | None = None) -> None:
    print(' '.join(quote(str(arg)) for arg in args) + (' < INPUT' if input else ''), file=sys.stderr)
    run(args, check=True, input=input, env=env)


def bwrap(outdir: Path, args: list[str | Path], input: bytes | None = None) -> None:
    """
    Use bwrap to run the command with /nix binded to nix_dir.
    This is what the nixsa executable does, but without extra stuff.
    """
    nix_dir = str(outdir / 'nix')
    args1 = (
        ['bwrap', '--bind', nix_dir, '/nix', '--proc', '/proc', '--dev', '/dev', '--bind', '/tmp', '/tmp']
        + ['--bind', str(outdir), str(outdir)]
        + args
    )
    extra_env = {
        'NIX_USER_CONF_FILES': outdir / 'config/nix.conf',
        'NIX_CACHE_HOME': outdir / 'cache',
        'NIX_CONFIG_HOME': outdir / 'config',
        'NIX_DATA_HOME': outdir / 'share',
        'NIX_STATE_HOME': outdir / 'state',
    }
    env = os.environ | extra_env
    sh(args1, input, env=env)


def nixsa_build(closure_info: Path, outdir: Path) -> None:
    store_paths = closure_info.joinpath('store-paths').read_text().split()
    (nix_inst,) = [path for path in store_paths if path.split('-', 1)[1].startswith('nix-')]
    (cacert_inst,) = [path for path in store_paths if path.split('-', 1)[1].startswith('nss-cacert-')]
    (nixsa_inst,) = [path for path in store_paths if path.split('-', 1)[1].startswith('nixsa-bin-')]
    reginfo = closure_info.joinpath('registration').read_bytes()

    if outdir.exists():
        raise RuntimeError(f'{outdir} must not exist before the call')
    outdir = outdir.absolute()
    outdir.mkdir()

    nix_dir = outdir / 'nix'
    nix_dir.mkdir()
    store_dir = nix_dir / 'store'
    store_dir.mkdir()
    sh(['cp', '-a'] + store_paths + [store_dir])

    nix_dir.joinpath('var').mkdir()
    nix_dir.joinpath('var/nix').mkdir()
    bin_dir = outdir / 'bin'
    bin_dir.mkdir()

    # Create user directories
    state_dir = outdir / 'state'
    state_dir.mkdir()
    config_dir = outdir / 'config'
    config_dir.mkdir()
    config_dir.joinpath('nix.conf').write_text(NIX_CONF)
    data_dir = outdir / 'share'
    data_dir.mkdir()
    cache_dir = outdir / 'cache'
    cache_dir.mkdir()

    # Create the profile symlink (by default it will be an absolute path, we don't want that)
    state_dir.joinpath('profile').symlink_to('profiles/profile')

    # Initialize the nix DB
    bwrap(outdir, [f'{nix_inst}/bin/nix-store', '--load-db'], input=reginfo)

    # We use `nix-env -i` instead of `nix profile install`, since `nix profile` can seamlessly
    # migrate from nix-env, and not the other way round, so users will be free to choose whatever they prefer.

    # Install the nix, cacert and nixsa package
    bwrap(outdir, [f'{nix_inst}/bin/nix-env', '-i', nix_inst, cacert_inst, nixsa_inst])

    # Create a symlink bin/nixsa
    nixsa_inst_base = Path(nixsa_inst).name
    bin_dir.joinpath('nixsa').symlink_to(f'../nix/store/{nixsa_inst_base}/bin/nixsa')

    # Create the `nixsa.toml` marker file
    outdir.joinpath('nixsa.toml').write_text(NIXSA_TOML)

    # Create symlinks
    sh([outdir / 'bin/nixsa', '--symlinks'])


def main() -> None:
    from argparse import ArgumentParser

    parser = ArgumentParser(description='build the nixsa directory')
    parser.add_argument('closure_info', type=Path, help='path to a closure info dir, made of nix, cacert and nixsa-bin')
    parser.add_argument('outdir', type=Path)
    args = parser.parse_args()

    nixsa_build(args.closure_info, args.outdir)


if __name__ == '__main__':
    main()
